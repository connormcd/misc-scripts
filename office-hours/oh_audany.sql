REM
REM Standard disclaimer - anything in here can be used at your own risk.
REM 
REM It is very likely you'll need to edit the script for correct usernames/passwords etc.
REM 
REM No warranty or liability etc etc etc. See the license file in the git repo root
REM
REM *** USE AT YOUR OWN RISK ***
REM 

clear screen
@clean
set termout off
conn SYS_USER/PASSWORD@MY_PDB as sysdba
set termout off
grant create table to scott;
grant execute on dbms_flashback to scott;
conn USER/PASSWORD@MY_PDB
set termout off
exec aud_util.audit_util.drop_audit_support('SCOTT','EMP2',p_action=>'EXECUTE',p_force=>true)
drop sequence scott.audit_opseq;
-- create sequence scott.audit_opseq;
drop table scott.global_audit purge;
drop trigger SCOTT.EMP2_AUDIT_TRG;
drop table scott.emp2 cascade constraints purge;
create table scott.emp2 as 
select * from scott.emp;
alter table scott.emp2 add
constraint emp2_pk primary key ( empno );
delete from aud_util.audit_header
where table_name = 'EMP2';
set termout on
set lines 60
clear screen
set feedback on
set serverout on
set echo on
desc scott.emp2
pause
clear screen
begin
  aud_util.audit_util.generate_audit_support(
    'SCOTT','EMP2',p_action=>'EXECUTE');
end;
/
pause
clear screen
delete from scott.emp2
where rownum = 1;
pause
update scott.emp2
set sal = sal + 100
where rownum = 1;
commit;
pause
clear screen
desc aud_util.audit_header
pause
select *
from aud_util.audit_header
where table_name = 'EMP2'
@pr
pause
clear screen
desc aud_util.emp2
pause
select * 
from aud_util.emp2
@pr
pause
set lines 200
set long 12000
set long chunksize 1000
clear screen
select trigger_body
from dba_triggers
where owner = 'AUD_UTIL'
and trigger_name = 'AUD$EMP2_SCOTT'

pause
/
pause
clear screen
desc aud_util.pkg_emp2
pause
set lines 60
clear screen
alter table scott.emp2 add newcol date;
pause
desc aud_util.emp2
pause
set serverout on
begin
  aud_util.audit_util.generate_audit_support(
    'SCOTT','EMP2',p_action=>'EXECUTE');
end;
/
pause
desc aud_util.emp2
pause
clear screen
begin
  aud_util.audit_util.drop_audit_support(
    'SCOTT','EMP2',p_action=>'EXECUTE',p_force=>true);
end;
/
pause
clear screen
create sequence scott.audit_opseq cache 500;
pause
create table scott.global_audit (
  aud_id          number(20) generated by default on null as identity not null 
 ,aud_opseq       number(20) not null
 ,aud_user        varchar2(255 char) default on null 
                      coalesce(sys_context('APEX$SESSION','APP_USER'),user) not null
 ,aud_tstamp      timestamp default on null localtimestamp
 ,aud_table_name  varchar2(255) not null
 ,aud_operation   varchar2(1)  not null
 ,aud_action      varchar2(64) default  sys_context('userenv','module')
 ,aud_client_id   varchar2(64) default  sys_context('userenv','client_identifier')
 ,aud_host        varchar2(64) default  sys_context('userenv','host')
 ,aud_module      varchar2(64) default  sys_context('userenv','module')
 ,aud_os_user     varchar2(64) default  sys_context('userenv','os_user')
 ,aud_data        blob
 ,constraint global_audit_ck1 check ( aud_operation in ('I','U','D'))
 ,constraint global_audit_ck2 check ( aud_data is json format oson )
)
partition by range ( aud_tstamp )
interval ( numtoyminterval(1,'MONTH') )
( 
  partition p1 values less than ( timestamp '2025-01-01 00:00:00' )
);
pause
clear screen
create or replace trigger SCOTT.EMP2_AUDIT_TRG
  for insert or update or delete on SCOTT.EMP2
    compound trigger

  l_tname          varchar2(255) := 'EMP2';
  l_opseq          number;
  l_pre_delete_scn number;
  l_operation      varchar2(1) := 
    case when inserting then 'I'
         when deleting  then 'D'
         else 'U'
    end;
  l_rid rowid;
#pause
#clear screen  
  before statement is
  begin 
    --
    -- remember the SCN from when we started this DML. 
    -- We'll use this to get a pre-DML copy of the data (for deletes)
    --
    l_pre_delete_scn := dbms_flashback.get_system_change_number;
    --
    -- each trigger execution gets assigned a new sequence, 
    -- just in case we get niche scenarios where
    -- a single operation might end up with more DML on the same table
    --
    l_opseq          := audit_opseq.nextval;

    --
    -- Using a PTT to hold all rowids impacted.  
    -- (This could have been just a plsql nested table, but there
    -- a bug in current versions that causes ora-600s).
    --
    execute immediate 
      'create private temporary table ora$ptt_rid 
          ( opseq int, rid rowid )';
  exception
    when others then
      if sqlcode != -955 then raise; end if;
  end before statement;
#pause
#clear screen  
  after each row is
  begin
    if inserting or updating then  
      l_rid := :new.rowid;
    else
      l_rid := :old.rowid;
    end if;
    execute immediate 
        'insert into ora$ptt_rid values (:b1,:b2)' 
        using l_opseq, l_rid;
  end after each row;
#pause
#clear screen  
  after statement is
  begin
    if inserting or updating then   
      --
      -- Use JSON_OBJECT to consolidate all the columns into JSON
      --
      execute immediate '
        insert into global_audit(aud_opseq,aud_table_name,aud_operation,aud_data)
        select /*+ leading(r) */ r.opseq, :b1, :b2, json_object(t.*)
        from   EMP2 t, ora$ptt_rid r
        where t.rowid = r.rid
        and   r.opseq = :b3' 
      using in l_tname, in l_operation, in l_opseq;
    else
#pause
#clear screen  
    --
    -- For any "OLD" images, we'll use flashback query to get the state of the table
    -- before the DML commenced 
    --
      execute immediate '
        insert into global_audit(aud_opseq,aud_table_name,aud_operation,aud_data)
        select /*+ leading(r) */ r.opseq, :b1, :b2, json_object(t.*)
        from   EMP2 as of scn :b3 t, ora$ptt_rid r
        where t.rowid = r.rid
        and   r.opseq = :b4' 
      using l_tname, l_operation, l_pre_delete_scn, l_opseq;
    end if;      
    execute immediate 
      'delete ora$ptt_rid where opseq = :b1' 
    using l_opseq;
  end after statement;

end;
/
pause
clear screen
delete from scott.emp2
where rownum = 1;
pause
update scott.emp2
set sal = sal + 100
where rownum = 1;
commit;
pause
clear screen
select 
   aud_id
  ,aud_opseq
  ,aud_user
  ,aud_tstamp
  ,aud_table_name
  ,aud_operation
  ,aud_action
  ,aud_client_id
  ,aud_host
  ,aud_module
  ,aud_os_user
  ,json_serialize(aud_data) as data
from scott.global_audit
@pr
pause
clear screen
alter table scott.emp2 drop column sal;
alter table scott.emp2 drop column newcol;
alter table scott.emp2 rename column hiredate to startdate;
pause
clear screen
delete from scott.emp2
where rownum = 1;
update scott.emp2
set startdate = startdate + 100
where rownum = 1;
commit;
pause
select 
   aud_id
  ,aud_opseq
  ,aud_user
  ,aud_tstamp
  ,aud_table_name
  ,aud_operation
  ,aud_action
  ,aud_client_id
  ,aud_host
  ,aud_module
  ,aud_os_user
  ,json_serialize(aud_data) as data
from scott.global_audit
@pr
